Machete ejercicios freertos 10-16

10_ Se crean 3 tareas: 2 senders 1 reciever. Ambos sender con prioridad 1 y el reciever de prioridad 2 ==> Se ejecuta siempre la tarea reciever de prioridad más alta. Esta quiere leer de la cola, pero inicialmente no tiene nada ==> Se bloquea la tarea (se le indica cuánto tiempo debe estar bloqueada esta tarea). La tarea se bloquea 100 ms, y luego las tareas sender que tienen prioridad 1 se ejecutan en round-robin. Las dos tareas escriben en la cola sus valores. La función taskYIELD() cede el resto de su tiempo a la tarea 2. Luego de los 100 ms, la tarea reciever puede leer la cola bien y envía los datos cargados por UART.

11_ Se crean 3 tareas: 2 sendesr 1 reciever. Ambos sender con prioridad 2 y el reciever con prioridad 1 ==> Se ejecutan siempre los senders en round-robin. Estas envían datos a una cola que tiene 3 de tamaño máx. Una vez que la cola está llena las tareas que quieren encolar se bloquean por 100 ms. En ese momento la tarea reciever se comienza a ejecutar, debido a que las tareas de prioridad superior se bloquean. Esta última desencola uno de los datos y lo envía por UART. Luego de que pasen los 100 ms esta tarea nunca se ejecuta porque es de prioridad inferior y se ejecutan los senders.

12_ Se crea un semáforo binario. Se setean las interrupciones de software (PREGUNTAR BIEN). Se crea una tarea "Handler" asociada a la interrupción. Se la crea con la prioridad más alta para que se asegure su ejecución cuando se active la interrupción. Se crea una tarea "Periodic" de prioridad inferior, la cual crea una interrupción por software. Una vez que esta interrupción se ejecuta, se invoca a la función "vSoftwareInterruptHandler". Esta invoca a "xSemaphoreGiveFromISR", dando el semáforo y permitiendo la ejecución de la tarea "Handler". Esta toma el semáforo. Luego, como tiene la prioridad más alta esta quiere tomar el semáforo nuevamente y se bloquea, dando lugar a que se ejecute nuevamente la tarea "Periodic".

13_ En este ejemplo se crea la misma cantidad de tareas que en el 12 con las mismas prioridades. La diferencia es que el semáforo que se crea es un "Counting semaphore" de 10 posiciones y de valor inicial 0. Dentro de la rutina de interrupción se dan 3 semáforos que se acumulan. Luego la tarea "Handler" toma esos semáforos de a uno con "xSemaphoreTake". Una vez que se tomas los semáforos 3 veces luego la tarea se bloquea, permitiendo ejecutar a la tarea "Periodic" y repitiendo el ciclo.

14_ Se crean 2 tareas, "vStringPrinter" de prioridad 2 y "vIntegerGenerator" de prioridad 1 ==> Siempre se ejecuta la de prioridad 2. Dentro de la tarea "vStringPrinter" se invoca a la función para leer una cola "xQueueReceive", pero como está vacía la tarea se bloquea, por lo que se ejecuta la tarea "vIntegerGenerator". Esta tarea se ejecuta cada 200 ms por la invocación a "vTaskDelayUntil". La tarea se encarga de encolar 5 datos y luego fuerza una interrupción. Dentro de la interrupción se lee con "xQueueReceiveFromISR" hasta que la cola queda vacía (¿SI SE QUIERE LEER DE UNA COLA VACÍA NO DEBERÍA BLOQUEARSE LA TAREA?). Con la función "xQueueSendToBackFromISR" se encolan datos. Luego se libera la interrupción. Luego la tarea "vStringPrinter" puede leer de la cola. 

15_ Se crea un semáforo mutex con "xSemaphoreCreateMutex". Se crean dos tareas "Print 1" de prioridad 1 y "Print 2" de prioridad 2 ==> Se ejecuta siempre la tarea "Print 2". Esta toma el mutex con "xSemaphoreTake" y se apodera del recurso "stdout". Escribe y luego da el mútex y se va a dormir por la invocación de "vTaskDelay" un número aleatorio de tiempo. Entonces la la tarea "Print 1" puede ejecutarse. Y tomar el mútex. Si se cumpliera ese tiempo antes de que la tarea 1 libere el mútex, la tarea 2 se bloquearía ya que quiso acceder al mútex que está bloqueado por la tarea 1. En este caso no hay una tercera tarea pero si la hubiera podría ocurrir una inversión de prioridad.

16_ Se crean 3 tareas, "Print 1" de prioridad 1, "Print 2" de prioridad 2, y "Gatekeeper" de prioridad 0 ==> Se ejecuta siempre la tarea "Print 2". Esta tarea, a diferencia del caso anterior, envía el dato que quiere transmitir a una cola. Luego se bloquea con "vTaskDelay" una cantidad de tiempo aleatoria, permitiendo que se ejecute la tarea "Print 1" de prioridad 1. Esta hace lo mismo que la 2 pero con otro mensaje y se bloquea otra cantidad de tiempo aleatoria, dando lugar a la ejecución del "Gatekeeper" y a la tarea Idle que tienen la misma prioridad. 